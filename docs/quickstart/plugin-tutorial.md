# Plugin Development Tutorial

Learn to build OpenCode plugins by creating a simple greeting tool. This hands-on guide covers architecture, implementation, testing, and installation using the greeting plugin as a working example.

## What You'll Build

By the end of this tutorial, you'll have a complete working plugin that:

- Defines a custom tool with validated arguments
- Registers tools with OpenCode's plugin system
- Includes unit and integration tests
- Can be installed and used in any OpenCode session

**Final result**: A `greeting` tool that generates personalized messages.

## Prerequisites

- **Node.js** 18+ or **Bun** (recommended for faster builds)
- Basic TypeScript knowledge
- Understanding of async/await patterns

## Section 1: Understanding OpenCode Plugins

### Architecture Overview

OpenCode plugins extend Claude's capabilities by:

1. **Registering tools** - Add custom functions Claude can call
2. **Defining skills** - Inject domain knowledge for specific contexts
3. **Providing APIs** - Export reusable code for other plugins

### How Plugins Load

OpenCode loads plugins during initialization:

```
1. Read opencode.jsonc → Get plugin list
2. Load each plugin from npm
3. Import from ./plugin entry point
4. Call exported function with PluginInput
5. Register returned tools/skills/APIs
```

**Critical path**: `package.json exports["./plugin"]` → `src/plugin.ts` → exported function

### Plugin Contract

Every plugin must export a function that returns a `Plugin` object:

```typescript
import type { Plugin, PluginInput } from "@opencode-ai/plugin";

export default function plugin(input: PluginInput): Plugin {
  return {
    name: "my-plugin",
    version: "0.1.0",
    tools: [...],      // Register custom tools
    skills: [...],      // Inject skills (optional)
  };
}
```

**Rules:**
- Export **only functions** from `plugin.ts` (no classes, constants, or objects)
- The default export receives `PluginInput` (session context)
- Return object must match `Plugin` type

## Section 2: Setting Up Plugin Structure

### Step 1: Initialize Project

```bash
mkdir greeting-plugin
cd greeting-plugin
bun init -y
```

### Step 2: Configure package.json

Create `package.json`:

```json
{
  "name": "@my-org/greeting-plugin",
  "version": "0.1.0",
  "type": "module",
  "description": "Example OpenCode plugin demonstrating custom tool basics",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./plugin": {
      "import": "./dist/plugin.js",
      "types": "./dist/plugin.d.ts"
    }
  },
  "scripts": {
    "build": "bun build ./src/index.ts --outfile ./dist/index.js --target node && bun build ./src/plugin.ts --outfile ./dist/plugin.js --target node && tsc",
    "dev": "bun --watch src/plugin.ts",
    "test": "bun test",
    "typecheck": "tsc --noEmit"
  },
  "peerDependencies": {
    "@opencode-ai/plugin": "*"
  },
  "devDependencies": {
    "@opencode-ai/plugin": "latest",
    "@types/bun": "latest",
    "typescript": "^5.7.0"
  }
}
```

**Key fields explained:**

| Field | Purpose |
|-------|---------|
| `type: "module"` | Required for ESM support |
| `exports["./plugin"]` | **Critical** - OpenCode loads plugins from this entry |
| `peerDependencies` | Declare OpenCode dependency (don't bundle it) |
| `build` script | Compile TypeScript → JavaScript + types |

### Step 3: Create Directory Structure

```bash
mkdir -p src tests
```

Final structure:

```
greeting-plugin/
├── src/
│   ├── plugin.ts       # Plugin entry point (REQUIRED)
│   └── index.ts       # Public API exports
├── tests/
│   ├── plugin.test.ts # Plugin unit tests
│   └── integration.test.ts # Integration tests
├── dist/             # Generated by build (don't edit)
├── package.json
├── tsconfig.json
└── README.md
```

### Step 4: Configure TypeScript

Create `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

## Section 3: Implementing Your First Tool

Following TDD principles, we'll write tests first, then implement.

### Step 1: Write Failing Test (RED)

Create `tests/plugin.test.ts`:

```typescript
import { describe, it, expect } from "bun:test";

describe("greeting tool", () => {
  it("generates personalized greeting", async () => {
    // Import tool from plugin implementation
    const { greeting } = await import("../src/plugin");

    // Execute tool with test input
    const result = await greeting.execute({ name: "Alice" });

    // Verify expected behavior
    expect(result).toBe("Hello, Alice! Welcome to OpenCode plugin development.");
  });

  it("handles empty name", async () => {
    const { greeting } = await import("../src/plugin");

    const result = await greeting.execute({ name: "" });

    expect(result).toContain("Hello");
  });
});
```

Run test - it will fail (we haven't implemented the tool yet):

```bash
bun test tests/plugin.test.ts
# FAIL: Error: Cannot find module '../src/plugin'
```

### Step 2: Implement Minimal Tool (GREEN)

Create `src/plugin.ts`:

```typescript
import type { Plugin, PluginInput } from "@opencode-ai/plugin";
import { tool } from "@opencode-ai/plugin";

/**
 * Greeting Tool
 *
 * Simple greeting tool that demonstrates OpenCode tool basics.
 * Takes a name parameter and returns a personalized greeting message.
 */
export const greeting = tool({
  description: "Generate a personalized greeting message",
  args: {
    name: tool
      .schema()
      .string()
      .describe("Name of the person to greet"),
  },
  execute: ({ name }) => {
    return `Hello, ${name}! Welcome to OpenCode plugin development.`;
  },
});

/**
 * Plugin Entry Point
 *
 * This is the main plugin function that registers all tools with OpenCode.
 * OpenCode's plugin loader calls this function during initialization.
 *
 * CRITICAL: This file must ONLY export functions. Exporting classes or
 * constants will cause plugin loading to fail.
 */
export default function plugin(input: PluginInput): Plugin {
  return {
    name: "greeting-plugin",
    version: "0.1.0",
    tools: [greeting],
  };
}
```

Create `src/index.ts` for public API exports:

```typescript
/**
 * Public API for programmatic usage
 *
 * External code can import from here, but OpenCode loads from `./plugin`.
 */
export { greeting } from "./plugin";
export { plugin } from "./plugin";
```

Run test again:

```bash
bun test tests/plugin.test.ts
# ✓ greeting tool generates personalized greeting
# ✓ greeting tool handles empty name
# 2 pass
```

### Step 3: Refactor (REFACTOR)

Test passes, but we can improve error handling:

```typescript
// Enhanced version with validation
export const greeting = tool({
  description: "Generate a personalized greeting message",
  args: {
    name: tool
      .schema()
      .string()
      .min(1, "Name cannot be empty")
      .describe("Name of the person to greet"),
  },
  execute: ({ name }) => {
    const trimmedName = name.trim();
    return `Hello, ${trimmedName}! Welcome to OpenCode plugin development.`;
  },
});
```

Update test to expect validation error:

```typescript
it("validates non-empty name", async () => {
  const { greeting } = await import("../src/plugin");

  // Validation should fail for empty string
  await expect(greeting.execute({ name: "" })).rejects.toThrow();
});
```

Run tests - all should pass:

```bash
bun test tests/plugin.test.ts
```

## Section 4: Testing Your Plugin

### Unit Tests

Test individual tools in isolation:

```typescript
// tests/plugin.test.ts
describe("greeting tool", () => {
  it("generates personalized greeting", async () => {
    const { greeting } = await import("../src/plugin");
    const result = await greeting.execute({ name: "Alice" });
    expect(result).toBe("Hello, Alice! Welcome to OpenCode plugin development.");
  });

  it("trims whitespace from name", async () => {
    const { greeting } = await import("../src/plugin");
    const result = await greeting.execute({ name: "  Alice  " });
    expect(result).toBe("Hello, Alice! Welcome to OpenCode plugin development.");
  });

  it("rejects empty name", async () => {
    const { greeting } = await import("../src/plugin");
    await expect(greeting.execute({ name: "" })).rejects.toThrow();
  });
});
```

Run unit tests:

```bash
bun test tests/plugin.test.ts
```

### Integration Tests

Test plugin loading and registration:

```typescript
// tests/integration.test.ts
import { describe, it, expect } from "bun:test";

describe("plugin integration", () => {
  it("registers tools correctly", async () => {
    // Load plugin module
    const pluginModule = await import("../src/plugin");

    // Call plugin function with mock input
    const pluginResult = await pluginModule.default({
      sessionId: "test-session",
      agent: "test-agent",
    });

    // Verify plugin structure
    expect(pluginResult).toHaveProperty("name", "greeting-plugin");
    expect(pluginResult).toHaveProperty("version", "0.1.0");
    expect(pluginResult.tools).toHaveLength(1);

    // Verify tool metadata
    const greetingTool = pluginResult.tools[0];
    expect(greetingTool.description).toBe("Generate a personalized greeting message");
    expect(greetingTool.args).toHaveProperty("name");
  });

  it("tool executes with valid input", async () => {
    const { greeting } = await import("../src/plugin");

    const result = await greeting.execute({ name: "Bob" });

    expect(typeof result).toBe("string");
    expect(result).toContain("Hello, Bob");
  });
});
```

Run all tests:

```bash
bun test
```

### Test Coverage Best Practices

✅ **DO:**
- Test success and failure cases
- Test validation rules
- Test edge cases (empty strings, special characters)
- Keep tests fast (<100ms per test)

❌ **DON'T:**
- Test implementation details (private methods)
- Mock what you don't own (unless necessary)
- Skip tests without tracking issues
- Write slow tests (avoid external dependencies)

## Section 5: Installing and Using Your Plugin

### Step 1: Build Plugin

```bash
bun install
bun run build
```

Verify output:

```bash
ls -la dist/
# Should see: index.js, index.d.ts, plugin.js, plugin.d.ts
```

### Step 2: Install Globally

```bash
npm install -g @my-org/greeting-plugin
```

Or use `bun link` for local development:

```bash
# In plugin directory
bun link

# In target project
bun link @my-org/greeting-plugin
```

### Step 3: Configure OpenCode

Create or edit `~/.config/opencode/opencode.jsonc`:

```jsonc
{
  "plugins": [
    "@my-org/greeting-plugin"
  ]
}
```

**Important:** Use package name, not file path. OpenCode resolves from npm.

### Step 4: Restart OpenCode

Restart OpenCode to load the new plugin:

```bash
# Restart OpenCode process
opencode
```

### Step 5: Use Your Tool

In an OpenCode session, the `greeting` tool is now available:

```
You: Generate a greeting for Alice
Claude: [Calls greeting tool with name="Alice"]
Tool output: Hello, Alice! Welcome to OpenCode plugin development.
```

### Verification Checklist

✅ Plugin builds without errors
✅ All tests pass
✅ Plugin installs globally
✅ `opencode.jsonc` includes package name
✅ Tool appears in OpenCode session
✅ Tool executes successfully

## Section 6: Next Steps

### Adding More Tools

Expand your plugin with additional functionality:

```typescript
export const farewell = tool({
  description: "Generate a farewell message",
  args: {
    name: tool.schema().string().describe("Name of person saying goodbye"),
  },
  execute: ({ name }) => {
    return `Goodbye, ${name}! Thanks for using OpenCode.`;
  },
});

export default function plugin(input: PluginInput): Plugin {
  return {
    name: "greeting-plugin",
    version: "0.1.0",
    tools: [greeting, farewell], // Add multiple tools
  };
}
```

### Advanced Patterns

#### 1. Context-Aware Tools

Access session information from `PluginInput`:

```typescript
export default function plugin(input: PluginInput): Plugin {
  const sessionId = input.sessionId;

  return {
    name: "context-aware-plugin",
    tools: [
      tool({
        description: "Log session info",
        args: {},
        execute: () => {
          return `Session ID: ${sessionId}, Agent: ${input.agent}`;
        },
      }),
    ],
  };
}
```

#### 2. Error Handling

Wrap tool logic in try-catch:

```typescript
export const riskyTool = tool({
  description: "Tool with error handling",
  args: { input: tool.schema().string() },
  execute: ({ input }) => {
    try {
      // Potentially failing operation
      const result = JSON.parse(input);
      return { success: true, data: result };
    } catch (error) {
      return {
        success: false,
        error: "Failed to parse input",
        details: error.message,
      };
    }
  },
});
```

#### 3. Async Operations

Tool functions can be async:

```typescript
export const asyncTool = tool({
  description: "Tool with async operation",
  args: { url: tool.schema().string().url() },
  execute: async ({ url }) => {
    const response = await fetch(url);
    return await response.text();
  },
});
```

### Publishing to npm

Follow the official publishing workflow:

1. **Create changeset** (for versioning):
   ```bash
   bunx changeset
   ```

2. **Build and publish**:
   ```bash
   bun run build
   bun publish --access public
   ```

3. **Tag release**:
   ```bash
   git tag v0.1.0
   git push --tags
   ```

## Common Mistakes

### ❌ Wrong: Missing `./plugin` export

```json
// package.json
"exports": {
  ".": { "import": "./dist/index.js" }  // Only main export
}
```

**Fix:** OpenCode requires `./plugin` export.

```json
"exports": {
  ".": { "import": "./dist/index.js" },
  "./plugin": { "import": "./dist/plugin.js" }  // Required!
}
```

### ❌ Wrong: Exporting non-functions from plugin.ts

```typescript
// plugin.ts
export const VERSION = "1.0.0";  // ❌ Breaks plugin loading
export class Helper {}  // ❌ Breaks plugin loading
export default plugin;  // ✅ Only this works
```

**Rule:** Plugin entry point (`src/plugin.ts`) must export **only functions**.

### ❌ Wrong: Using dependencies instead of peerDependencies

```json
"dependencies": {
  "@opencode-ai/plugin": "^1.0.0"  // ❌ Causes version conflicts
}
```

**Fix:** Use `peerDependencies` to let OpenCode manage version.

```json
"peerDependencies": {
  "@opencode-ai/plugin": "*"  // ✅ Accepts any version
}
```

### ❌ Wrong: Testing implementation details

```typescript
// Fragile test
test("internal helper function", () => {
  expect(pluginHelper("input")).toBe("output");  // Tests private logic
});
```

**Fix:** Test through public API.

```typescript
// Robust test
test("tool produces correct output", () => {
  const result = tool.execute({ input: "input" });
  expect(result).toBe("output");  // Tests behavior
});
```

## Troubleshooting

**"Cannot find module '@opencode-ai/plugin'"**
```bash
bun install  # Install peer dependency
```

**"Plugin not loading in OpenCode"**
- Verify `./plugin` export in package.json
- Check that only functions are exported from `src/plugin.ts`
- Ensure build ran successfully (`ls dist/`)
- Confirm package is installed globally

**"Tool validation fails unexpectedly"**
- Check Zod schema rules (min, max, url, email)
- Verify argument names match between schema and execute function
- Test with `tool.schema().parse()` directly to debug

**"Tests pass but tool doesn't work in OpenCode"**
- Verify plugin is in `opencode.jsonc`
- Restart OpenCode after installation
- Check OpenCode logs for loading errors
- Test tool manually: `await greeting.execute({ name: "Test" })`

## Summary

Key takeaways from this tutorial:

1. **Plugin contract**: Export a function returning `Plugin` object from `src/plugin.ts`
2. **Tool definition**: Use `tool()` with schema validation and execute function
3. **TDD workflow**: Write failing test, implement minimal code, refactor
4. **Testing**: Unit tests for tools, integration tests for plugin loading
5. **Installation**: Build, publish to npm, add to `opencode.jsonc`

## Reference

- **[@opencode-ai/plugin API](https://github.com/opencode-ai/opencode)** - Full plugin API reference
- **[Greeting Plugin Example](../packages/opencode-swarm-plugin/examples/greeting-plugin/)** - Complete working example
- **[Quickstart Guide](./quickstart/)** - Additional setup and development guides
- **[Zod Documentation](https://zod.dev)** - Schema validation library used by tools

## What's Next

- **[Plugin Entry Point](./quickstart/02-plugin-entry.md)** - Write your plugin.ts file
- **[Skills Example](./quickstart/03-skills-example.md)** - Create domain knowledge injection
- **[Installation and Testing](./quickstart/04-installation.md)** - Install locally and publish to npm
